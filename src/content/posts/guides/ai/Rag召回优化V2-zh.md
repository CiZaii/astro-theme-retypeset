---
title: RAG召回优化-V2
published: 2025-08-09T00:00:00.000Z
tags:
  - Rag
  - 召回
lang: zh
abbrlink: rag-retrieval
password: "ragRetrieval"

aicommit: '这里是Zang-AI，这篇文章探讨了四种优化信息检索召回结果的后置处理方案，旨在解决标题和大纲对检索结果的过度影响以及短段落内容不完整的问题。方案一通过计算并应用干扰率来动态调整高干扰段落的分数。方案二在检索后动态对文档进行二次分段和语义合并，以形成更完整的段落再排序。方案三采用父子分段的层次化索引，将短段落合并为父文档进行初步检索，实现了多粒度查询。方案四则是一种更彻底的数据重入库方法，在入库前就通过智能分段与合并优化索引质量。文章最后还对比了四种方案的优劣，并给出了实践建议。'
---

# 方案一（召回后置处理）：干扰率处理方案

## 1. 核心思想
保留原有分段方式，但计算每个段落的“干扰率”（标题/大纲对检索结果的影响程度），对高干扰率段落进行特殊处理，减少标题和大纲对检索结果的不当影响。

## 2. 实现流程
1. 素材库：保存完整段落（标题 + 大纲 + 正文）。
2. 常规检索：使用用户查询在素材库中进行初步检索。
3. 动态计算干扰率：对检索结果计算干扰率。
4. 分数调整：对高干扰率段落进行分值衰减。
5. 重新排序：按调整后分数重排。

### 2.1 伪代码
```pseudo
// 1. 维护单一素材库索引
素材库 = 创建向量索引(所有段落)  // 完整格式: "标题\n大纲\n正文"

// 2. 检索实现
function 查询(用户输入):
    初步结果 = 素材库.检索(用户输入, top_k=10)  // 多取一些用于重排

    // 计算干扰率
    for 结果 in 初步结果:
        标题, 大纲, 正文 = 分离组成部分(结果.文本)
        干扰率 = 计算干扰率(标题 + 大纲, 正文, 用户输入)
        结果.干扰率 = 干扰率

    干扰率阈值 = 1.3
    for 结果 in 初步结果:
        if 结果.干扰率 > 干扰率阈值:
            结果.调整后分数 = 结果.原始分数 / 结果.干扰率
        else:
            结果.调整后分数 = 结果.原始分数

    排序后结果 = 按(调整后分数)排序(初步结果)
    return 排序后结果.top(5)
```

### 2.2 干扰率计算示例
示例段落（分段 3）：
```
***
```
拆分：
- 标题+大纲：行 1–3
- 正文：行 4–10

计算（示例假设值）：
- 标题+大纲 与 (标题+大纲+正文) 相似度：0.72
- 标题+大纲 与 正文 相似度：0.50
- 干扰率 = 0.72 / 0.50 = 1.44 > 1.3（高干扰）

### 3. 具体案例
用户查询：`"事业单位领导人员管理规定\n二、任职资格"`

#### 3.1 初步检索结果（示例）
| 结果 | 原始分数 | 说明 |
| ---- | -------- | ---- |
| 分段4 | 0.88 | 与“任职资格”直接相关 |
| 分段3 | 0.84 | 任职条件相关 |
| 分段2 | 0.76 | 总则部分 |

#### 3.2 干扰率计算（示例）
- 分段4：干扰率 0.96（低）
- 分段3：干扰率 1.26（接近阈值）
- 分段2：干扰率 2.14（高）

#### 3.3 分数调整
- 分段4：0.88 → 0.88
- 分段3：0.84 → 0.84
- 分段2：0.76 → 0.36（0.76 / 2.14）

#### 3.4 排序
1. 分段4（0.88）
2. 分段3（0.84）
3. 分段2（0.36）

### 4. 接口测试
接口：`POST http://example.com:8080/ai/chat/autoReference`

请求体：
```json
{
  "searchWord": "人工智能技术\n二、人工智能的发展历程",
  "interference": 1.01
}
```

返回（节选）：
```json
{
  "success": true,
  "data": [
    {
      "标题+大纲+正文": [ { "score": 0.8789253, "id": "2149793922940857", "content": "..." } ],
      "正文": [ { "score": 0.866995, "id": "21497939229408532", "content": "..." } ],
      "计算干扰值": [ { "interferenceRatio": 1.0090, "fullContentScore": 0.87149847 } ],
      "最后取5个": [ { "score": 0.86370814, "id": "21497939229408515" } ]
    }
  ]
}
```

---

# 方案二（召回后置处理）：素材检索重组

## 1. 核心思想
不改变原有数据存储结构，在检索过程中动态处理段落，解决短段落问题并提升语义完整性。

## 2. 实现流程
1. 初步检索与文档定位：向量召回或标题分词定位候选文档。
2. 文档分段与排版分析：利用智能分段工具 + 排版分析引擎提取结构。
3. 语义段落合并：基于结构层级与语义相似度合并短段。
4. 重新向量化与精排：对重组段向量化 + reranker 排序。

### 2.1 描述
- 通过检索快速定位文档。
- 提取原文并二次分段、结构分析。
- 合并相邻短段落，保留章节语义完整性。

### 3. 示例
用户查询：`企业管理制度规范岗位要求详细说明`

识别原文章节（示意）并合并：
- 合并段 A = 分段1 + 分段2
- 合并段 B = 分段3 + 分段4
- 合并段 C = 分段11 + 分段12 + 分段13
- 分段6/7/8按长度与语义决定是否合并（示例保留 7,8 独立）

最终检索排序：
1. 分段8（岗位要求）
2. 分段7（岗位条件）
3. 合并段 B（总则）
4. 合并段 C（任期规定）
5. 合并段 A（引言）

---

# 方案三（数据重新入库）：父子分段层次化索引

## 1. 核心思想
利用父子分段结构建立层次化索引：父分段（合并短段）作为高层入口，子分段保留细粒度信息。

## 2. 实现流程
1. 保留原始细粒度子分段（标题+大纲+正文）。
2. 扫描相邻短段落（< 阈值）并按主题合并生成父分段（移除非首段标题/大纲）。
3. 构建双层向量索引：子分段索引 + 父分段检索索引。
4. 查询时先检索父分段，再视需要下钻子分段。

### 2.1 伪代码（节选）
```pseudo
获取所有子分段
父分段集合 = []
已合并IDs = set()
阈值 = 200
for i in range(len(子分段)):
  p = 子分段[i]
  if p.字数 < 阈值:
    group = [p]
    j = i + 1
    while j < len(子分段) and 主题相关(p, 子分段[j]) and 子分段[j].字数 < 阈值:
      group.append(子分段[j]); j += 1
    if len(group) > 1:
      父文本 = 合并(group)  // 仅首段保留标题+大纲
      父分段集合.add(父文本)
      标记已合并
      i = j - 1

检索索引用: 父分段 + 未合并子分段
```

### 3. 合并文本策略
父分段 = 子分段1（标题+大纲+正文） + "\n" + 子分段2（正文） + ...

### 4. 案例（节选）
阈值 200 字：分段7 与 分段8 合并 → 父分段 A。

结构：
- 保留：1,2,3,4,5,6,9
- 合并：7+8 → 父分段A

向量索引：
```pseudo
检索向量集 = { 分段1..6, 父分段A, 分段9 }
父子映射 = { 父分段A: [分段7, 分段8] }
```

检索示例：`"企业管理制度规范\n一、任期规定"`
- 父分段A：0.87
- 分段9：0.42
- 分段3：0.31

对子分段差值策略：
- 若子分段7=0.88 与 8=0.80 差值小 → 返回父分段A
- 若 7=0.88 与 8=0.60 差值大 → 可仅返回子分段7

---

# 方案四（数据重新入库）：切换分段合并逻辑

## 1. 核心思想
预处理式优化：在入库前完成分段、排版分析与语义合并，提高索引底座质量。

## 2. 实施步骤
1. 文档智能分段：使用分段工具获取细粒度段落。
2. 排版分析：使用排版引擎识别标题、层级、字体等结构特征。
3. 段落智能合并：依据排版 + 语义相似度合并短段，形成语义完整单元。
4. 重新向量化与入库：替换旧索引，建立新结构。

---

# 四种方案对比（简述）
| 方案 | 改动范围 | 实施周期 | 优点 | 风险/成本 |
| ---- | -------- | -------- | ---- | -------- |
| 方案一 | 检索后置重排 | 短 | 快速上线，侵入低 | 阈值调优依赖实验 |
| 方案二 | 检索流程动态重组 | 中 | 兼顾完整性与实时性 | 运行期额外计算 |
| 方案三 | 新增层次索引 | 中偏长 | 多粒度检索灵活 | 维护双索引复杂度 |
| 方案四 | 数据重入库 | 长 | 基础质量最高 | 改造面大，上线成本高 |

---

# 参数与实践建议
- 干扰率阈值初始建议：1.1 ~ 1.3（可用分桶 A/B 搜索点击验证）。
- 短段落阈值：150~220 字需结合文档平均长度分布调优（P95 参考）。
- 合并策略优先级：结构层级 > 语义相似度 > 长度补足。
- Reranker 使用：优先在重组/父分段集合上应用（减少调用次数）。
- 监控指标：召回点击率、首屏相关性人工标注分、平均段落字数、重复内容率。

---

# 后续迭代方向
1. 干扰率特征加入学习排序模型（融合 BM25 / 向量 / Meta Features）。
2. 引入跨段拼接生成 Query Expansion（减少标题投机匹配）。
3. 父子索引内局部稀疏化（减少存储 + 提升检索速率）。
4. 动态阈值：根据 Query 类型（导航 / 信息 / 任务）自适应调整干扰率阈值。

> 注：文中示例分值均为假设值，仅用于说明计算流程。
